<!DOCTYPE html>
<html lang="id">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>HMI Drag & Drop</title>
        <script src="https://cdn.tailwindcss.com"></script>
        <!-- Memuat Konva.js, library untuk canvas 2D -->
        <script src="https://unpkg.com/konva@9.3.6/konva.min.js"></script>
        <style>
            #container {
                background-color: #374151;
                /* Darker grid */
                background-image: linear-gradient(
                        to right,
                        #4b5563 1px,
                        transparent 1px
                    ),
                    linear-gradient(to bottom, #4b5563 1px, transparent 1px);
                background-size: 20px 20px;
            }

            #container.dotted-grid {
                /* Grid menjadi titik-titik saat snap dinonaktifkan */
                background-image: radial-gradient(circle at 0 0, #4b5563 1px, transparent 1px);
                background-size: 20px 20px;
            }

            .btn-disabled,
            button:disabled {
                background-color: #4b5563;
                color: #9ca3af;
                cursor: not-allowed;
            }

            .loader {
                border: 4px solid #4b5563;
                border-top: 4px solid #22d3ee;
                border-radius: 50%;
                width: 20px;
                height: 20px;
                animation: spin 1s linear infinite;
                display: inline-block;
            }

            @keyframes spin {
                0% {
                    transform: rotate(0deg);
                }

                100% {
                    transform: rotate(360deg);
                }
            }

            /* Style untuk toggle switch */
            .switch {
                position: relative;
                display: inline-block;
                width: 60px;
                height: 34px;
            }

            .switch input {
                opacity: 0;
                width: 0;
                height: 0;
            }

            .slider {
                position: absolute;
                cursor: pointer;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: #ccc;
                transition: 0.4s;
                border-radius: 34px;
            }

            .slider:before {
                position: absolute;
                content: "";
                height: 26px;
                width: 26px;
                left: 4px;
                bottom: 4px;
                background-color: white;
                transition: 0.4s;
                border-radius: 50%;
            }

            input:checked + .slider {
                background-color: #22d3ee;
            }

            input:checked + .slider:before {
                transform: translateX(26px);
            }

            /* Styling untuk chat UI */
            #chat-log {
                height: 280px;
                overflow-y: auto;
                display: flex;
                flex-direction: column;
                gap: 8px;
            }

            .chat-message {
                padding: 8px 12px;
                border-radius: 12px;
                max-width: 90%;
                word-wrap: break-word;
            }

            .user-message {
                background-color: #2563eb;
                align-self: flex-end;
            }

            .model-message {
                background-color: #4b5563;
                align-self: flex-start;
                display: flex;
                align-items: center;
            }

            .thinking-details {
                align-self: flex-start;
                max-width: 90%;
                margin-top: -4px;
                margin-bottom: 4px;
            }

            .thinking-details summary {
                cursor: pointer;
                color: #9ca3af;
                font-size: 0.8rem;
                padding-left: 12px;
            }

            .thinking-details pre {
                background-color: #111827;
                border: 1px solid #374151;
                border-radius: 8px;
                padding: 8px;
                font-size: 0.75rem;
                white-space: pre-wrap;
                word-wrap: break-word;
                margin-top: 4px;
            }
        </style>
    </head>

    <body class="bg-gray-800 text-white font-sans">
        <div class="flex h-screen flex-col md:flex-row">
            <!-- Toolbar Samping -->
            <div
                class="w-full md:w-80 bg-gray-900 p-4 shadow-lg flex flex-col space-y-4 overflow-y-auto"
            >
                <h1 class="text-xl font-bold text-center text-cyan-400">
                    Panel Kontrol HMI
                </h1>

                <div
                    class="flex items-center justify-between p-2 bg-gray-800 rounded-lg"
                >
                    <span id="mode-label" class="font-bold text-cyan-300"
                        >Mode Desain</span
                    >
                    <label class="switch"
                        ><input type="checkbox" id="mode-toggle" /><span
                            class="slider"
                        ></span
                    ></label>
                </div>

                <div
                    class="grid grid-cols-2 gap-2 pt-2 border-t border-gray-700"
                >
                    <button
                        id="undo-btn"
                        class="flex items-center justify-center gap-2 bg-gray-700 hover:bg-gray-600 p-2 rounded-lg transition-colors"
                        disabled
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="20"
                            height="20"
                            viewBox="0 0 24 24"
                            fill="none"
                            stroke="currentColor"
                            stroke-width="2"
                            stroke-linecap="round"
                            stroke-linejoin="round"
                        >
                            <path d="M3 3v6h6" />
                            <path d="M21 12A9 9 0 0 0 6.47 6.53L3 10" />
                        </svg>
                        <span>Undo</span>
                    </button>
                    <button
                        id="redo-btn"
                        class="flex items-center justify-center gap-2 bg-gray-700 hover:bg-gray-600 p-2 rounded-lg transition-colors"
                        disabled
                    >
                        <span>Redo</span>
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="20"
                            height="20"
                            viewBox="0 0 24 24"
                            fill="none"
                            stroke="currentColor"
                            stroke-width="2"
                            stroke-linecap="round"
                            stroke-linejoin="round"
                        >
                            <path d="M21 3v6h-6" />
                            <path d="M3 12a9 9 0 0 0 14.53 6.47L21 14" />
                        </svg>
                    </button>
                </div>

                <div
                    id="add-component-panel"
                    class="space-y-3 pt-4 border-t border-gray-700"
                >
                    <h2 class="text-lg font-semibold">Tambah Manual</h2>
                    <button
                        data-component="bit-lamp"
                        class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg"
                    >
                        Bit Lamp
                    </button>
                    <button
                        data-component="bit-switch"
                        class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg"
                    >
                        Bit Switch
                    </button>
                    <button
                        data-component="word-lamp"
                        class="w-full bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg"
                    >
                        Word Lamp
                    </button>
                    <button
                        data-component="numeric-display"
                        class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg"
                    >
                        Numeric Display
                    </button>
                    <button
                        data-component="label"
                        class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg"
                    >
                        Label
                    </button>
                </div>

                <h2 class="text-lg font-semibold text-cyan-400">
                    Koneksi MQTT
                </h2>
                <div class="space-y-2">
                    <div>
                        <label for="mqtt-host" class="block text-sm font-medium text-gray-300">Host</label>
                        <input type="text" id="mqtt-host" value="broker.hivemq.com"
                            class="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 text-sm text-white focus:outline-none focus:ring-2 focus:ring-cyan-500" />
                    </div>
                    <div>
                        <label for="mqtt-port" class="block text-sm font-medium text-gray-300">Port</label>
                        <input type="number" id="mqtt-port" value="8000"
                            class="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 text-sm text-white focus:outline-none focus:ring-2 focus:ring-cyan-500" />
                    </div>
                    <button id="mqtt-connect-btn"
                        class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">
                        Connect
                    </button>
                    <div id="mqtt-status" class="text-center text-gray-400 text-sm"></div>
                </div>

                <div
                    id="status-info"
                    class="text-center text-gray-400 text-sm pt-4"
                >
                    Selamat datang!
                </div>
            </div>

            <div
                id="canvas-wrapper"
                class="flex-1 p-2 md:p-4 bg-gray-800 flex items-center justify-center"
            >
                <div
                    id="container"
                    class="w-full h-full shadow-2xl rounded-lg"
                ></div>
            </div>
        </div>

        <div
            id="context-menu"
            style="display: none"
            class="absolute bg-gray-800 border border-gray-600 rounded-lg shadow-xl z-50 p-4 w-64"
        >
            <div
                class="flex justify-between items-center mb-2 pb-2 border-b border-gray-700"
            >
                <h3 id="context-menu-title" class="font-bold text-cyan-300">
                    Edit Properti
                </h3>
                <button
                    id="close-context-menu"
                    class="text-gray-400 hover:text-white text-2xl leading-none"
                >
                    &times;
                </button>
            </div>
            <div id="context-menu-content" class="space-y-2 text-sm"></div>
        </div>

        <div id="ai-popup-container">
            <div
                id="ai-popup-chat"
                class="hidden fixed bottom-20 right-6 w-80 bg-gray-900 border border-gray-700 rounded-lg shadow-2xl z-40 transition-all duration-300 transform-gpu"
            >
                <div id="ai-chat-panel" class="flex flex-col space-y-2 p-3">
                    <div
                        class="flex justify-between items-center border-b border-gray-700 pb-2"
                    >
                        <h2 class="text-lg font-semibold text-cyan-300">
                            Asisten AI 💬
                        </h2>
                        <div class="flex space-x-2">
                            <button
                                id="ai-settings-btn"
                                class="text-gray-400 hover:text-white"
                            >
                                <svg
                                    xmlns="http://www.w3.org/2000/svg"
                                    width="20"
                                    height="20"
                                    viewBox="0 0 24 24"
                                    fill="none"
                                    stroke="currentColor"
                                    stroke-width="2"
                                    stroke-linecap="round"
                                    stroke-linejoin="round"
                                    class="lucide lucide-settings"
                                >
                                    <path
                                        d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 .73v.5a2 2 0 0 1-1 1.73l-.14.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 .73v.45a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.05-.03.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-.73v-.5a2 2 0 0 1 1-1.73l.14-.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-.73V4a2 2 0 0 0-2-2z"
                                    />
                                    <circle cx="12" cy="12" r="3" />
                                </svg>
                            </button>
                            <button
                                id="close-ai-popup"
                                class="text-gray-400 hover:text-white text-2xl leading-none"
                            >
                                &times;
                            </button>
                        </div>
                    </div>
                    <div
                        id="chat-log"
                        class="p-2 bg-gray-800 rounded-lg flex-grow"
                    ></div>
                    <div class="flex items-center space-x-2">
                        <input
                            type="text"
                            id="chat-input"
                            class="flex-grow bg-gray-700 border border-gray-600 rounded-lg p-2 text-sm text-white focus:outline-none focus:ring-2 focus:ring-cyan-500"
                            placeholder="Ketik pesan..."
                        />
                        <button
                            id="send-chat-btn"
                            class="bg-cyan-600 hover:bg-cyan-700 text-white font-bold p-2 rounded-lg"
                        >
                            <svg
                                xmlns="http://www.w3.org/2000/svg"
                                width="24"
                                height="24"
                                viewBox="0 0 24 24"
                                fill="none"
                                stroke="currentColor"
                                stroke-width="2"
                                stroke-linecap="round"
                                stroke-linejoin="round"
                            >
                                <line x1="22" y1="2" x2="11" y2="13"></line>
                                <polygon
                                    points="22 2 15 22 11 13 2 9 22 2"
                                ></polygon>
                            </svg>
                        </button>
                    </div>
                    <!-- AI Settings Panel (Initially Hidden) -->
                    <div
                        id="ai-settings-panel"
                        class="hidden absolute top-0 left-0 w-full h-full bg-gray-900 p-4 rounded-lg"
                    >
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-lg font-semibold text-cyan-300">
                                Pengaturan AI
                            </h3>
                            <button
                                id="close-ai-settings"
                                class="text-gray-400 hover:text-white text-2xl leading-none"
                            >
                                &times;
                            </button>
                        </div>
                        <label
                            for="gemini-api-key"
                            class="block text-sm font-medium text-gray-300"
                            >API Key Gemini</label
                        >
                        <input
                            type="text"
                            name="gemini-api-key"
                            id="gemini-api-key"
                            class="mt-1 block w-full rounded-md bg-gray-700 border-gray-600 shadow-sm focus:border-cyan-500 focus:ring-cyan-500 sm:text-sm"
                            placeholder="Masukkan API Key Anda"
                        />
                    </div>
                </div>
            </div>
            <button
                id="ai-fab"
                class="fixed bottom-6 right-6 bg-cyan-600 hover:bg-cyan-500 text-white rounded-full p-4 shadow-lg z-50 transition-transform duration-200 hover:scale-110"
            >
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    class="lucide lucide-message-circle-code"
                >
                    <path d="M7.9 20A9 9 0 1 0 4 16.1L2 22Z" />
                    <path d="m10 10-2 2 2 2" />
                    <path d="m14 10 2 2-2 2" />
                </svg>
            </button>
        </div>

        <script type="module">
            // --- MQTT ---
            let mqttClient = null;
            let mqttConnected = false;
            let mqttReconnectInterval = null;
            const Paho = window.Paho; // Ensure Paho is globally available

            function connectMqtt(host, port, username, password) {
                if (mqttClient && mqttClient.isConnected()) {
                    mqttClient.disconnect();
                }

                const clientId = "hmi_client_" + Math.random().toString(16).substr(2, 8);
                const uri = `ws://${host}:${port}/mqtt`; // Assuming WebSocket for browser

                updateStatus(`Menghubungkan ke MQTT broker di ${host}:${port}...`, 0);

                mqttClient = new Paho.Mqtt.Client(host, Number(port), "/mqtt", clientId);

                mqttClient.onConnectionLost = onConnectionLost;
                mqttClient.onMessageArrived = onMessageArrived;

                const connectOptions = {
                    onSuccess: onConnectSuccess,
                    onFailure: onConnectFailure,
                    cleanSession: true,
                    reconnect: false, // We'll handle reconnect manually
                };

                if (username) {
                    connectOptions.userName = username;
                }
                if (password) {
                    connectOptions.password = password;
                }

                try {
                    mqttClient.connect(connectOptions);
                } catch (e) {
                    console.error("MQTT Connect Error:", e);
                    updateStatus(`Gagal koneksi MQTT: ${e.message}`, 5000);
                    mqttConnected = false;
                    document.getElementById("mqtt-connect-btn").textContent = "Connect";
                    document.getElementById("mqtt-connect-btn").classList.remove("bg-red-600", "hover:bg-red-700");
                    document.getElementById("mqtt-connect-btn").classList.add("bg-blue-600", "hover:bg-blue-700");
                }
            }

            function onConnectSuccess() {
                mqttConnected = true;
                updateStatus("Terhubung ke MQTT broker!", 3000);
                document.getElementById("mqtt-connect-btn").textContent = "Disconnect";
                document.getElementById("mqtt-connect-btn").classList.remove("bg-blue-600", "hover:bg-blue-700");
                document.getElementById("mqtt-connect-btn").classList.add("bg-red-600", "hover:bg-red-700");

                // Subscribe to all component addresses
                layer.find(".hmi-component").forEach(node => {
                    if (node.attrs.address) {
                        mqttClient.subscribe(node.attrs.address);
                        console.log(`Subscribed to ${node.attrs.address}`);
                    }
                });
            }

            function onConnectFailure(responseObject) {
                mqttConnected = false;
                updateStatus(`Koneksi MQTT gagal: ${responseObject.errorMessage}`, 5000);
                document.getElementById("mqtt-connect-btn").textContent = "Connect";
                document.getElementById("mqtt-connect-btn").classList.remove("bg-red-600", "hover:bg-red-700");
                document.getElementById("mqtt-connect-btn").classList.add("bg-blue-600", "hover:bg-blue-700");
            }

            function onConnectionLost(responseObject) {
                mqttConnected = false;
                if (responseObject.errorCode !== 0) {
                    updateStatus(`Koneksi MQTT terputus: ${responseObject.errorMessage}. Mencoba menghubungkan kembali...`, 0);
                    mqttReconnectInterval = setInterval(() => {
                        const host = document.getElementById("mqtt-host").value;
                        const port = document.getElementById("mqtt-port").value;
                        connectMqtt(host, port);
                    }, 5000); // Coba reconnect setiap 5 detik
                }
            }

            function onMessageArrived(message) {
                tagDatabase[message.destinationName] = parseFloat(message.payloadString);
                layer.find(".hmi-component").forEach(n => n.updateState?.());
            }
            // --- INISIALISASI ---
            let stage, layer, tr, guideLayer;
            let clipboard = null;
            let pasteOffset = 0;
            let isSimulationMode = false;
            let simulationInterval;
            let tagDatabase = {};
            let chatHistory = [];
            let currentContextMenuNode = null;
            let undoStack = [];
            let redoStack = [];
            const GRID_SIZE = 20;

            let selectionRectangle;
            let x1, y1;
            let dragStartPositions = null; // Untuk menyimpan posisi awal saat drag

            const container = document.getElementById("container");
            const modeToggle = document.getElementById("mode-toggle");
            const modeLabel = document.getElementById("mode-label");
            const deleteBtn = document.getElementById("delete-btn");
            const statusInfo = document.getElementById("status-info");
            const addComponentPanel = document.getElementById(
                "add-component-panel"
            );
            const chatLog = document.getElementById("chat-log");
            const chatInput = document.getElementById("chat-input");
            const sendChatBtn = document.getElementById("send-chat-btn");
            const contextMenu = document.getElementById("context-menu");
            const contextMenuContent = document.getElementById(
                "context-menu-content"
            );
            const contextMenuTitle =
                document.getElementById("context-menu-title");
            const closeContextMenuBtn =
                document.getElementById("close-context-menu");
            const aiPopupChat = document.getElementById("ai-popup-chat");
            const aiFab = document.getElementById("ai-fab");
            const closeAiPopupBtn = document.getElementById("close-ai-popup");
            const aiSettingsBtn = document.getElementById("ai-settings-btn");
            const aiSettingsPanel =
                document.getElementById("ai-settings-panel");
            const closeAiSettingsBtn =
                document.getElementById("close-ai-settings");
            const undoBtn = document.getElementById("undo-btn");
            const mqttHostInput = document.getElementById("mqtt-host");
            const mqttPortInput = document.getElementById("mqtt-port");
            const mqttConnectBtn = document.getElementById("mqtt-connect-btn");
            const mqttStatusDiv = document.getElementById("mqtt-status");
            const redoBtn = document.getElementById("redo-btn");

            // --- PABRIK KOMPONEN ---
            const componentFactory = {
                create(type, props = {}) {
                    const uniqueId =
                        props.id || "hmi-id-" + crypto.randomUUID();
                    const defaults = {
                        x: 100,
                        y: 100,
                        address: `${type
                            .substring(0, 3)
                            .toUpperCase()}_${uniqueId.substring(7, 11)}`,
                    };
                    const config = { ...defaults, ...props };
                    if (!(config.address in tagDatabase))
                        tagDatabase[config.address] =
                            config.state || config.value || 0;
                    return this.creator(type, uniqueId, config);
                },
                creator(type, id, config) {
                    let group;
                    switch (type) {
                        case "bit-lamp":
                            group = this.createBitLamp(id, config);
                            break;
                        case "bit-switch":
                            group = this.createBitSwitch(id, config);
                            break;
                        case "word-lamp":
                            group = this.createWordLamp(id, config);
                            break;
                        case "numeric-display":
                            group = this.createNumericDisplay(id, config);
                            break;
                        case "label":
                            group = this.createLabel(id, config);
                            break;
                        default:
                            throw new Error(`Unknown component type: ${type}`);
                    }
                    if (group) {
                        group.on("dragstart", (e) => {
                            guideLayer.show();
                            // Catat posisi awal semua node yang dipilih dan pointer
                            dragStartPositions = {
                                pointer: stage.getPointerPosition(),
                                nodes: {},
                            };
                            tr.nodes().forEach((node) => {
                                dragStartPositions.nodes[node.id()] = {
                                    x: node.x(),
                                    y: node.y(),
                                };
                            });
                        });
                        group.on("dragend", () => {
                            saveState();
                            guideLayer.hide();
                            dragStartPositions = null; // Bersihkan setelah selesai
                        });
                        group.on("dragmove", handleDragMove);
                    }
                    return group;
                },
                createBitLamp(id, config) {
                    const group = new Konva.Group({
                        id: id,
                        x: config.x,
                        y: config.y,
                        draggable: false,
                        name: "hmi-component",
                    });
                    group.setAttrs({
                        componentType: "bit-lamp",
                        label: "Indikator",
                        shapeType: "circle",
                        offColor: "#555555",
                        onColor: "#22c55e",
                        ...config,
                    });
                    const lampShape = new Konva.Circle({
                        radius: 20,
                        name: "lamp-shape",
                    });
                    group.add(lampShape);
                    group.on("click", (e) => {
                        if (isSimulationMode) return;
                        // if we are selecting with shift key, we can select multiple nodes
                        const isSelected = tr.nodes().indexOf(group) >= 0;
                        if (!e.evt.shiftKey) {
                            // if we are selecting without shift key, just select this node
                            selectNodes(isSelected ? [] : [group]);
                        } else {
                            // if we are selecting with shift key
                            if (isSelected) {
                                const nodes = tr.nodes().slice(); // copy
                                nodes.splice(nodes.indexOf(group), 1); // remove one
                                selectNodes(nodes);
                            } else {
                                const nodes = tr.nodes().concat([group]);
                                selectNodes(nodes);
                            }
                        }
                    });

                    group.updateState = function () {
                        const state = tagDatabase[this.attrs.address] || 0;
                        const existingShape = this.findOne(".lamp-shape");
                        let currentShapeType =
                            existingShape instanceof Konva.Circle
                                ? "circle"
                                : "rect";
                        if (this.attrs.shapeType !== currentShapeType) {
                            existingShape.destroy();
                            let newShape;
                            if (this.attrs.shapeType === "circle")
                                newShape = new Konva.Circle({ radius: 20 });
                            else
                                newShape = new Konva.Rect({
                                    width: 40,
                                    height: 40,
                                    offsetX: 20,
                                    offsetY: 20,
                                });
                            newShape.name("lamp-shape");
                            this.add(newShape);
                            newShape.moveToBottom();
                        }
                        this.findOne(".lamp-shape").fill(
                            state === 1
                                ? this.attrs.onColor
                                : this.attrs.offColor
                        );
                    };
                    group.updateState();
                    return group;
                },
                createBitSwitch(id, config) {
                    const group = new Konva.Group({
                        id: id,
                        x: config.x,
                        y: config.y,
                        draggable: false,
                        name: "hmi-component",
                    });
                    group.setAttrs({
                        componentType: "bit-switch",
                        label: "Saklar",
                        offColor: "#d9534f",
                        onColor: "#5cb85c",
                        offText: "OFF",
                        onText: "ON",
                        ...config,
                    });
                    const background = new Konva.Rect({
                        width: 80,
                        height: 40,
                        cornerRadius: 5,
                        name: "background",
                    });
                    group.add(background);
                    const text = new Konva.Text({
                        width: 80,
                        height: 40,
                        align: "center",
                        verticalAlign: "middle",
                        fontSize: 16,
                        fill: "white",
                        fontStyle: "bold",
                        name: "state-text",
                    });
                    group.add(text);
                    group.on("click", (e) => {
                        if (isSimulationMode) return;
                        const isSelected = tr.nodes().indexOf(group) >= 0;
                        if (!e.evt.shiftKey) {
                            selectNodes(isSelected ? [] : [group]);
                        } else {
                            if (isSelected) {
                                const nodes = tr.nodes().slice();
                                nodes.splice(nodes.indexOf(group), 1);
                                selectNodes(nodes);
                            } else {
                                const nodes = tr.nodes().concat([group]);
                                selectNodes(nodes);
                            }
                        }
                    });
                    group.updateState = function () {
                        const state = tagDatabase[this.attrs.address] || 0;
                        this.findOne(".background").fill(
                            state === 1
                                ? this.attrs.onColor
                                : this.attrs.offColor
                        );
                        this.findOne(".state-text").text(
                            state === 1 ? this.attrs.onText : this.attrs.offText
                        );
                    };
                    group.on("click tap", () => {
                        if (isSimulationMode)
                            tagDatabase[group.attrs.address] =
                                (tagDatabase[group.attrs.address] || 0) === 1
                                    ? 0
                                    : 1;
                    });
                    group.updateState();
                    return group;
                },
                createWordLamp(id, config) {
                    const group = new Konva.Group({
                        id: id,
                        x: config.x,
                        y: config.y,
                        draggable: false,
                        name: "hmi-component",
                    });
                    group.setAttrs({
                        componentType: "word-lamp",
                        label: "Status Lamp",
                        states: [
                            { value: 0, text: "STOPPED", color: "#d9534f" },
                            { value: 1, text: "RUNNING", color: "#5cb85c" },
                        ],
                        ...config,
                    });
                    const background = new Konva.Rect({
                        width: 120,
                        height: 40,
                        fill: "#333",
                        stroke: "#555",
                        strokeWidth: 2,
                        cornerRadius: 5,
                        name: "background",
                    });
                    group.add(background);
                    group.on("click", (e) => {
                        if (isSimulationMode) return;
                        const isSelected = tr.nodes().indexOf(group) >= 0;
                        if (!e.evt.shiftKey) {
                            selectNodes(isSelected ? [] : [group]);
                        } else {
                            if (isSelected) {
                                const nodes = tr.nodes().slice();
                                nodes.splice(nodes.indexOf(group), 1);
                                selectNodes(nodes);
                            } else {
                                const nodes = tr.nodes().concat([group]);
                                selectNodes(nodes);
                            }
                        }
                    });
                    const text = new Konva.Text({
                        width: 120,
                        height: 40,
                        align: "center",
                        verticalAlign: "middle",
                        fontSize: 16,
                        fill: "white",
                        fontStyle: "bold",
                        name: "state-text",
                    });
                    group.add(text);
                    group.updateState = function () {
                        const value = tagDatabase[this.attrs.address] || 0;
                        const stateConfig = this.attrs.states.find(
                            (s) => s.value == value
                        ) || { text: "INVALID", color: "#f0ad4e" };
                        this.findOne(".background").fill(stateConfig.color);
                        this.findOne(".state-text").text(stateConfig.text);
                    };
                    group.updateState();
                    return group;
                },
                createNumericDisplay(id, config) {
                    const group = new Konva.Group({
                        id: id,
                        x: config.x,
                        y: config.y,
                        draggable: false,
                        name: "hmi-component",
                    });
                    group.setAttrs({
                        componentType: "numeric-display",
                        label: "Suhu",
                        units: "°C",
                        decimalPlaces: 2,
                        ...config,
                    });
                    const background = new Konva.Rect({
                        width: 120,
                        height: 50,
                        fill: "#111",
                        stroke: "#555",
                        strokeWidth: 2,
                        cornerRadius: 5,
                    });
                    group.add(background);
                    group.on("click", (e) => {
                        if (isSimulationMode) return;
                        const isSelected = tr.nodes().indexOf(group) >= 0;
                        if (!e.evt.shiftKey) {
                            selectNodes(isSelected ? [] : [group]);
                        } else {
                            if (isSelected) {
                                const nodes = tr.nodes().slice();
                                nodes.splice(nodes.indexOf(group), 1);
                                selectNodes(nodes);
                            } else {
                                const nodes = tr.nodes().concat([group]);
                                selectNodes(nodes);
                            }
                        }
                    });
                    const valueText = new Konva.Text({
                        y: 25,
                        width: 120,
                        align: "center",
                        fontSize: 24,
                        fill: "#22d3ee",
                        fontStyle: "bold",
                        name: "value-text",
                    });
                    group.add(valueText);
                    const labelText = new Konva.Text({
                        y: 5,
                        width: 120,
                        align: "center",
                        fontSize: 12,
                        fill: "#9ca3af",
                        name: "label-text",
                    });
                    group.add(labelText);
                    group.updateState = function () {
                        const value = tagDatabase[this.attrs.address] || 0;
                        const val = parseFloat(value).toFixed(
                            this.attrs.decimalPlaces
                        );
                        this.findOne(".value-text").text(val);
                        this.findOne(".label-text").text(
                            this.attrs.label + ` (${this.attrs.units})`
                        );
                    };
                    group.updateState();
                    return group;
                },
                createLabel(id, config) {
                    const group = new Konva.Group({
                        id: id,
                        x: config.x,
                        y: config.y,
                        draggable: false,
                        name: "hmi-component",
                    });
                    group.setAttrs({
                        componentType: "label",
                        text: "Label Teks",
                        fontSize: 14,
                        fill: "white",
                        width: 100,
                        align: "center",
                        ...config,
                    });
                    const labelText = new Konva.Text({
                        text: group.attrs.text,
                        fontSize: group.attrs.fontSize,
                        fill: group.attrs.fill,
                        width: group.attrs.width,
                        align: group.attrs.align,
                        name: "label-text",
                    });
                    group.add(labelText);
                    group.on("transformend", function () {
                        // Dapatkan node teks di dalamnya
                        const textNode = this.findOne(".label-text");
                        // Hitung lebar baru dari skala
                        const newWidth = this.width() * this.scaleX();
                        // Terapkan lebar baru ke node teks
                        textNode.width(newWidth);
                        // Simpan lebar baru di atribut grup untuk konsistensi
                        this.setAttr("width", newWidth);
                        // Reset skala agar font tidak terdistorsi
                        this.scaleX(1);
                        this.scaleY(1);
                    });

                    group.on("click", (e) => {
                        if (isSimulationMode) return;
                        const isSelected = tr.nodes().indexOf(group) >= 0;
                        if (!e.evt.shiftKey) {
                            selectNodes(isSelected ? [] : [group]);
                        } else {
                            if (isSelected) {
                                const nodes = tr.nodes().slice();
                                nodes.splice(nodes.indexOf(group), 1);
                                selectNodes(nodes);
                            } else {
                                const nodes = tr.nodes().concat([group]);
                                selectNodes(nodes);
                            }
                        }
                    });
                    group.updateState = function () {
                        this.findOne(".label-text").text(this.attrs.text);
                        this.findOne(".label-text").fontSize(
                            this.attrs.fontSize
                        );
                        this.findOne(".label-text").fill(this.attrs.fill);
                        this.findOne(".label-text").width(this.attrs.width);
                        this.findOne(".label-text").align(this.attrs.align);
                    };
                    group.updateState();
                    return group;
                },
            };

            // --- SISTEM UNDO/REDO ---
            function saveState() {
                const state = { components: [], tags: { ...tagDatabase } };
                layer.find(".hmi-component").forEach((node) => {
                    const cleanAttrs = {
                        componentType: node.attrs.componentType,
                        address: node.attrs.address,
                        label: node.attrs.label,
                        shapeType: node.attrs.shapeType,
                        offColor: node.attrs.offColor,
                        onColor: node.attrs.onColor,
                        offText: node.attrs.offText,
                        onText: node.attrs.onText,
                        states: node.attrs.states,
                        units: node.attrs.units,
                        decimalPlaces: node.attrs.decimalPlaces,
                        text: node.attrs.text,
                        fontSize: node.attrs.fontSize,
                        fill: node.attrs.fill,
                        width: node.attrs.width,
                        align: node.attrs.align,
                    };
                    const componentData = {
                        id: node.id(),
                        x: node.x(),
                        y: node.y(),
                        ...cleanAttrs,
                    };
                    Object.keys(componentData).forEach(
                        (key) =>
                            componentData[key] === undefined &&
                            delete componentData[key]
                    );
                    state.components.push(componentData);
                });
                undoStack.push(JSON.stringify(state));
                redoStack = [];
                updateUndoRedoButtons();
            }

            function restoreState(stateString) {
                const state = JSON.parse(stateString);
                layer.find(".hmi-component").forEach((node) => node.destroy());
                tr.nodes([]);
                tagDatabase = { ...state.tags };
                state.components.forEach((componentData) => {
                    const component = componentFactory.create(
                        componentData.componentType,
                        componentData
                    );
                    layer.add(component);
                });
            }

            function handleUndo() {
                if (undoStack.length <= 1) return;
                const currentState = undoStack.pop();
                redoStack.push(currentState);
                const lastState = undoStack[undoStack.length - 1];
                restoreState(lastState);
                updateUndoRedoButtons();
            }

            function handleRedo() {
                if (redoStack.length === 0) return;
                const nextState = redoStack.pop();
                undoStack.push(nextState);
                restoreState(nextState);
                updateUndoRedoButtons();
            }

            function getCurrentState() {
                const state = { components: [], tags: { ...tagDatabase } };
                layer.find(".hmi-component").forEach((node) => {
                    const cleanAttrs = {
                        componentType: node.attrs.componentType,
                        address: node.attrs.address,
                        label: node.attrs.label,
                        shapeType: node.attrs.shapeType,
                        offColor: node.attrs.offColor,
                        onColor: node.attrs.onColor,
                        offText: node.attrs.offText,
                        onText: node.attrs.onText,
                        states: node.attrs.states,
                        units: node.attrs.units,
                        decimalPlaces: node.attrs.decimalPlaces,
                    };
                    const componentData = {
                        id: node.id(),
                        x: node.x(),
                        y: node.y(),
                        ...cleanAttrs,
                    };
                    Object.keys(componentData).forEach(
                        (key) =>
                            componentData[key] === undefined &&
                            delete componentData[key]
                    );
                    state.components.push(componentData);
                });
                return JSON.stringify(state);
            }

            function updateUndoRedoButtons() {
                undoBtn.disabled = undoStack.length <= 1;
                redoBtn.disabled = redoStack.length === 0;
            }

            undoBtn.addEventListener("click", handleUndo);
            redoBtn.addEventListener("click", handleRedo);

            function updateStatus(message, duration = 2000) {
                statusInfo.textContent = message;
                if (duration > 0) {
                    setTimeout(() => {
                        // Only reset if the message hasn't changed in the meantime
                        if (statusInfo.textContent === message) {
                            statusInfo.textContent = "Selamat datang!";
                        }
                    }, duration);
                }
            }

            function handleCopy() {
                const selectedNodes = tr.nodes();
                if (selectedNodes.length === 0) {
                    clipboard = null;
                    return;
                }

                // Reset paste offset on every new copy action
                pasteOffset = 0;

                clipboard = selectedNodes.map((node) => {
                    const properties = { ...node.attrs };
                    delete properties.id;
                    delete properties.address;
                    return {
                        componentType: properties.componentType,
                        properties: properties,
                    };
                });

                updateStatus(`${clipboard.length} elemen disalin.`);
            }

            function handlePaste() {
                if (!clipboard || clipboard.length === 0) return;

                pasteOffset += GRID_SIZE;
                const newNodes = [];

                clipboard.forEach((item) => {
                    const newProps = { ...item.properties };
                    newProps.x += pasteOffset;
                    newProps.y += pasteOffset;

                    const newComponent = componentFactory.create(
                        item.componentType,
                        newProps
                    );
                    if (newComponent) {
                        layer.add(newComponent);
                        newNodes.push(newComponent);
                    }
                });

                if (newNodes.length > 0) {
                    saveState();
                    selectNodes(newNodes);
                    updateStatus(`${newNodes.length} elemen ditempel.`);
                }
            }

            // --- LOGIKA SNAPPING ---
            function getLineGuideStops(skipShape) {
                const vertical = [0, stage.width() / 2, stage.width()];
                const horizontal = [0, stage.height() / 2, stage.height()];
                stage.find(".hmi-component").forEach((guideItem) => {
                    if (guideItem === skipShape) return;
                    const box = guideItem.getClientRect();
                    vertical.push(
                        box.x,
                        box.x + box.width,
                        box.x + box.width / 2
                    );
                    horizontal.push(
                        box.y,
                        box.y + box.height,
                        box.y + box.height / 2
                    );
                });
                return {
                    vertical: vertical.flat(),
                    horizontal: horizontal.flat(),
                };
            }

            function getObjectSnappingEdges(node) {
                const box = node.getClientRect();
                const absPos = node.absolutePosition();
                return {
                    vertical: [
                        {
                            guide: Math.round(box.x),
                            offset: Math.round(absPos.x - box.x),
                            snap: "start",
                        },
                        {
                            guide: Math.round(box.x + box.width / 2),
                            offset: Math.round(
                                absPos.x - box.x - box.width / 2
                            ),
                            snap: "center",
                        },
                        {
                            guide: Math.round(box.x + box.width),
                            offset: Math.round(absPos.x - box.x - box.width),
                            snap: "end",
                        },
                    ],
                    horizontal: [
                        {
                            guide: Math.round(box.y),
                            offset: Math.round(absPos.y - box.y),
                            snap: "start",
                        },
                        {
                            guide: Math.round(box.y + box.height / 2),
                            offset: Math.round(
                                absPos.y - box.y - box.height / 2
                            ),
                            snap: "center",
                        },
                        {
                            guide: Math.round(box.y + box.height),
                            offset: Math.round(absPos.y - box.y - box.height),
                            snap: "end",
                        },
                    ],
                };
            }

            function drawGuides(guides) {
                guides.forEach((lg) => {
                    guideLayer.add(
                        new Konva.Line({
                            points: lg.points,
                            stroke: "rgb(255,0,0)",
                            strokeWidth: 1,
                            name: "guide-line",
                            dash: [4, 6],
                        })
                    );
                });
            }

            function handleDragMove(e) {
                // Jika tidak dalam mode drag, jangan lakukan apa-apa
                if (!dragStartPositions) {
                    return;
                }

                const activeNode = e.target;
                const initialNodePos = dragStartPositions.nodes[activeNode.id()];
                const initialPointerPos = dragStartPositions.pointer;
                const currentPointerPos = stage.getPointerPosition();

                // 1. Hitung pergeseran total pointer dari posisi awal
                let pointerDisplacement = {
                    x: currentPointerPos.x - initialPointerPos.x,
                    y: currentPointerPos.y - initialPointerPos.y,
                };

                // Jika tombol Alt ditekan, batasi gerakan ke satu sumbu (X atau Y)
                // berdasarkan pergerakan mouse yang paling dominan.
                if (e.evt.altKey) {
                    const absX = Math.abs(pointerDisplacement.x);
                    const absY = Math.abs(pointerDisplacement.y);

                    if (absX > absY) {
                        pointerDisplacement.y = 0; // Kunci sumbu Y
                    } else {
                        pointerDisplacement.x = 0; // Kunci sumbu X
                    }
                }

                // 2. Hitung posisi ideal (belum di-snap) untuk node yang aktif
                const idealPos = {
                    x: initialNodePos.x + pointerDisplacement.x,
                    y: initialNodePos.y + pointerDisplacement.y,
                };

                // 3. Terapkan logika snapping ke posisi ideal node aktif
                // Pindahkan sementara node ke posisi ideal untuk dihitung snappingnya
                activeNode.position(idealPos);

                guideLayer.destroyChildren();
                const lineGuideStops = getLineGuideStops(activeNode);
                const itemBounds = getObjectSnappingEdges(activeNode);
                const GUIDELINE_OFFSET = 5;
                let guides = [];
                let isSnappedToGuide = false; // Flag untuk menandai jika snap ke objek terjadi

                // Snapping ke pemandu (garis bantu)
                itemBounds.vertical.forEach((guideLine) => {
                    lineGuideStops.vertical.forEach((stop) => {
                        const diff = Math.abs(guideLine.guide - stop);
                        if (diff < GUIDELINE_OFFSET) {
                            activeNode.x(
                                Math.round(activeNode.x() - guideLine.guide + stop)
                            );
                            guides.push({ points: [stop, 0, stop, stage.height()] });
                            isSnappedToGuide = true;
                        }
                    });
                });
                itemBounds.horizontal.forEach((guideLine) => {
                    lineGuideStops.horizontal.forEach((stop) => {
                        const diff = Math.abs(guideLine.guide - stop);
                        if (diff < GUIDELINE_OFFSET) {
                            activeNode.y(
                                Math.round(activeNode.y() - guideLine.guide + stop)
                            );
                            guides.push({ points: [0, stop, stage.width(), stop] });
                            isSnappedToGuide = true;
                        }
                    });
                });
                drawGuides(guides);

                // Lakukan snap-to-grid selama tombol Shift tidak ditekan.
                // Ini akan menimpa snap-to-object jika posisinya tidak di grid,
                // mengembalikan prioritas ke snap-to-grid.
                if (!e.evt.shiftKey) {
                    activeNode.position({
                        x: Math.round(activeNode.x() / GRID_SIZE) * GRID_SIZE,
                        y: Math.round(activeNode.y() / GRID_SIZE) * GRID_SIZE,
                    });
                }

                // 4. Hitung pergeseran akhir untuk seluruh grup berdasarkan snapping
                const finalDisplacement = {
                    x: activeNode.x() - initialNodePos.x,
                    y: activeNode.y() - initialNodePos.y,
                };

                // 5. Terapkan pergeseran akhir ini ke SEMUA node yang dipilih
                tr.nodes().forEach((node) => {
                    const initialPos = dragStartPositions.nodes[node.id()];
                    if (initialPos) {
                        node.position({
                            x: initialPos.x + finalDisplacement.x,
                            y: initialPos.y + finalDisplacement.y,
                        });
                    }
                });
            }

            // --- EVENT HANDLERS & INITS ---
            window.addEventListener("load", () => {
                stage = new Konva.Stage({
                    container: "container",
                    width: container.clientWidth,
                    height: container.clientHeight,
                });
                layer = new Konva.Layer();
                guideLayer = new Konva.Layer();
                stage.add(layer, guideLayer);
                tr = new Konva.Transformer({
                    keepRatio: true,
                    ignoreStroke: true,
                });
                layer.add(tr);
                new ResizeObserver(() => {
                    stage.width(container.clientWidth);
                    stage.height(container.clientHeight);
                }).observe(container);

                // Event listeners untuk mengubah tampilan grid saat Shift ditekan
                window.addEventListener("keydown", (e) => {
                    // Hanya aktifkan jika Shift ditekan, tidak dalam mode simulasi,
                    // dan tidak sedang mengetik di input.
                    if (e.key !== "Shift" || isSimulationMode) return;
                    const activeEl = document.activeElement;
                    if (
                        activeEl.tagName === "INPUT" ||
                        activeEl.tagName === "TEXTAREA"
                    )
                        return;
                    container.classList.add("dotted-grid");
                });

                window.addEventListener("keyup", (e) => {
                    // Selalu kembalikan grid ke normal saat Shift dilepas.
                    if (e.key === "Shift") {
                        container.classList.remove("dotted-grid");
                    }
                });

                stage.on("click tap", (e) => {
                    hideContextMenu();
                    // if we are selecting with shift key, do nothing
                    if (e.evt.shiftKey) {
                        return;
                    }
                    if (e.target === stage) {
                        selectNodes([]);
                        return;
                    }

                    // if click on transformer, do nothing
                    if (e.target.getParent().className === "Transformer") {
                        return;
                    }
                });

                stage.on("mousedown", (e) => {
                    // do nothing if we mousedown on any shape
                    if (e.target !== stage || isSimulationMode) {
                        return;
                    }
                    e.evt.preventDefault();
                    const pos = stage.getPointerPosition();
                    x1 = pos.x;
                    y1 = pos.y;
                    selectionRectangle = new Konva.Rect({
                        fill: "rgba(0,161,255,0.3)",
                        visible: false,
                    });
                    layer.add(selectionRectangle);
                });

                stage.on("mousemove", (e) => {
                    if (!selectionRectangle) {
                        return;
                    }
                    e.evt.preventDefault();
                    const pos = stage.getPointerPosition();
                    selectionRectangle.visible(true);
                    selectionRectangle.width(pos.x - x1);
                    selectionRectangle.height(pos.y - y1);
                    selectionRectangle.x(x1);
                    selectionRectangle.y(y1);
                });

                stage.on("mouseup", (e) => {
                    if (!selectionRectangle) {
                        return;
                    }
                    e.evt.preventDefault();
                    // update visibility in case of cLick without move
                    selectionRectangle.visible(false);
                    const shapes = stage.find(".hmi-component");
                    const box = selectionRectangle.getClientRect();
                    const selected = shapes.filter((shape) =>
                        Konva.Util.haveIntersection(box, shape.getClientRect())
                    );
                    selectNodes(selected);
                    selectionRectangle.destroy();
                    selectionRectangle = null;
                });

                stage.on("contextmenu", (e) => {
                    e.evt.preventDefault();
                    const node = e.target.getParent();
                    if (
                        tr.nodes().length === 1 && // Only show for single selection
                        node &&
                        node.hasName("hmi-component") &&
                        !isSimulationMode
                    ) {
                        currentContextMenuNode = node;
                        populateContextMenu(node);
                        const containerRect = stage
                            .container()
                            .getBoundingClientRect();
                        contextMenu.style.display = "block";
                        contextMenu.style.top =
                            e.evt.clientY - containerRect.top + "px";
                        contextMenu.style.left =
                            e.evt.clientX - containerRect.left + "px";
                    } else {
                        hideContextMenu();
                    }
                });

                setMode(false);
                addMessageToChatLog(
                    "model",
                    "Halo! Saya asisten AI Anda. Apa yang bisa saya bantu rancang hari ini?"
                );
                saveState();
            });

            // MQTT Connection Event Listener
            mqttConnectBtn.addEventListener("click", () => {
                if (mqttConnected) {
                    mqttClient.disconnect();
                    mqttConnected = false;
                    mqttConnectBtn.textContent = "Connect";
                    mqttConnectBtn.classList.remove("bg-red-600", "hover:bg-red-700");
                    mqttConnectBtn.classList.add("bg-blue-600", "hover:bg-blue-700");
                    updateStatus("Terputus dari MQTT broker.", 3000);
                    clearInterval(mqttReconnectInterval);
                } else {
                    const host = mqttHostInput.value;
                    const port = mqttPortInput.value;
                    connectMqtt(host, port);
                }
            });


            // Sisa event handler (add, delete, keydown, AI popup, dll) tidak berubah dari versi sebelumnya.
            // Cukup salin fungsi-fungsi dari versi sebelumnya.
            function setMode(isSimulation) {
                isSimulationMode = isSimulation;
                tr.nodes([]);
                hideContextMenu();
                layer
                    .find(".hmi-component")
                    .forEach((node) => node.draggable(!isSimulation));
                tr.visible(!isSimulation);
                addComponentPanel.style.display = isSimulation
                    ? "none"
                    : "block";
                aiPopupChat.classList.add("hidden");
                aiFab.style.display = isSimulation ? "none" : "block";
                modeLabel.textContent = isSimulation
                    ? "Mode Simulasi"
                    : "Mode Desain";
                if (isSimulation) {
                    simulationInterval = setInterval(
                        () =>
                            layer
                                .find(".hmi-component")
                                .forEach((n) => n.updateState?.()),
                        200
                    );
                } else {
                    clearInterval(simulationInterval);
                }
            }
            modeToggle.addEventListener("change", (e) =>
                setMode(e.target.checked)
            );
            function selectNodes(nodes = []) {
                if (isSimulationMode) return;

                // Atur keepRatio berdasarkan node yang dipilih
                if (nodes.length === 1 && nodes[0].attrs.componentType === "label") {
                    tr.keepRatio(false);
                } else {
                    tr.keepRatio(true);
                }
                tr.nodes(nodes);

                if (nodes.length > 0) {
                    deleteBtn.disabled = false;
                    deleteBtn.classList.remove("btn-disabled");
                } else {
                    deleteBtn.disabled = true;
                    deleteBtn.classList.add("btn-disabled");
                }

                // Enable dragging for selected nodes, disable for others
                layer.find(".hmi-component").forEach((n) => {
                    const isSelected = nodes.includes(n);
                    n.draggable(isSelected);
                });
                hideContextMenu();
            }
            function hideContextMenu() {
                if (currentContextMenuNode) {
                    const originalState =
                        undoStack.length > 0
                            ? undoStack[undoStack.length - 1]
                            : "{}";
                    const currentState = getCurrentState();
                    if (originalState !== currentState) {
                        saveState();
                    }
                }
                contextMenu.style.display = "none";
                currentContextMenuNode = null;
            }
            function populateContextMenu(node) {
                if (!node) return;
                const attrs = node.attrs;
                contextMenuTitle.textContent = `Edit ${attrs.componentType}`;
                let html = ``;
                html += `<div class="mb-2"><label class="font-bold text-cyan-200">Address (Tag)</label><input type="text" data-prop="address" value="${attrs.address}" class="w-full bg-gray-600 p-1 rounded mt-1 font-mono"></div>`;
                html += `<div class="mb-2"><label class="font-bold">Label</label><input type="text" data-prop="label" value="${
                    attrs.label || ""
                }" class="w-full bg-gray-600 p-1 rounded mt-1"></div>`;
                switch (attrs.componentType) {
                    case "bit-lamp":
                        html += `<div class="mb-1"><label class="font-bold">Bentuk</label><select data-prop="shapeType" class="w-full bg-gray-600 p-1 rounded mt-1"><option value="circle" ${
                            attrs.shapeType === "circle" ? "selected" : ""
                        }>Lingkaran</option><option value="rect" ${
                            attrs.shapeType === "rect" ? "selected" : ""
                        }>Persegi</option></select></div>`;
                        html += `<div class="mb-1"><label class="font-bold">Warna ON</label><input type="color" data-prop="onColor" value="${attrs.onColor}" class="w-full h-8 bg-gray-600 p-0 rounded mt-1"></div>`;
                        html += `<div class="mb-1"><label class="font-bold">Warna OFF</label><input type="color" data-prop="offColor" value="${attrs.offColor}" class="w-full h-8 bg-gray-600 p-0 rounded mt-1"></div>`;
                        break;
                    case "numeric-display":
                        html += `<div class="mb-1"><label class="font-bold">Unit</label><input type="text" data-prop="units" value="${attrs.units}" class="w-full bg-gray-600 p-1 rounded mt-1"></div>`;
                        html += `<div class="mb-1"><label class="font-bold">Desimal</label><input type="number" data-prop="decimalPlaces" value="${attrs.decimalPlaces}" class="w-full bg-gray-600 p-1 rounded mt-1"></div>`;
                        break;
                    case "bit-switch":
                        html += `<div class="mb-1"><label class="font-bold">Teks OFF</label><input type="text" data-prop="offText" value="${attrs.offText}" class="w-full bg-gray-600 p-1 rounded mt-1"></div>`;
                        html += `<div class="mb-1"><label class="font-bold">Teks ON</label><input type="text" data-prop="onText" value="${attrs.onText}" class="w-full bg-gray-600 p-1 rounded mt-1"></div>`;
                        html += `<div class="mb-1"><label class="font-bold">Warna ON</label><input type="color" data-prop="onColor" value="${attrs.onColor}" class="w-full h-8 bg-gray-600 p-0 rounded mt-1"></div>`;
                        html += `<div class="mb-1"><label class="font-bold">Warna OFF</label><input type="color" data-prop="offColor" value="${attrs.offColor}" class="w-full h-8 bg-gray-600 p-0 rounded mt-1"></div>`;
                        break;
                    case "word-lamp":
                        html += `<div class="mb-1"><label class="font-bold">Status</label><select data-prop="states" class="w-full bg-gray-600 p-1 rounded mt-1"><option value='[{"value":0,"text":"STOPPED","color":"#d9534f"},{"value":1,"text":"RUNNING","color":"#5cb85c"}]' ${
                            JSON.stringify(attrs.states) ===
                            JSON.stringify([
                                { value: 0, text: "STOPPED", color: "#d9534f" },
                                { value: 1, text: "RUNNING", color: "#5cb85c" },
                            ])
                                ? "selected"
                                : ""
                        }>Default</option></select></div>`;
                        break;
                    case "label":
                        html += `<div class="mb-1"><label class="font-bold">Teks</label><input type="text" data-prop="text" value="${attrs.text}" class="w-full bg-gray-600 p-1 rounded mt-1"></div>`;
                        html += `<div class="mb-1"><label class="font-bold">Ukuran Font</label><input type="number" data-prop="fontSize" value="${attrs.fontSize}" class="w-full bg-gray-600 p-1 rounded mt-1"></div>`;
                        html += `<div class="mb-1"><label class="font-bold">Warna Teks</label><input type="color" data-prop="fill" value="${attrs.fill}" class="w-full h-8 bg-gray-600 p-0 rounded mt-1"></div>`;
                        html += `<div class="mb-1"><label class="font-bold">Lebar</label><input type="number" data-prop="width" value="${attrs.width}" class="w-full bg-gray-600 p-1 rounded mt-1"></div>`;
                        html += `<div class="mb-1"><label class="font-bold">Perataan</label><select data-prop="align" class="w-full bg-gray-600 p-1 rounded mt-1"><option value="left" ${
                            attrs.align === "left" ? "selected" : ""
                        }>Kiri</option><option value="center" ${
                            attrs.align === "center" ? "selected" : ""
                        }>Tengah</option><option value="right" ${
                            attrs.align === "right" ? "selected" : ""
                        }>Kanan</option></select></div>`;
                        break;
                    default:
                        console.warn(
                            `Tidak ada opsi konfigurasi untuk komponen ${attrs.componentType}`
                        );
                        return;
                }
                contextMenuContent.innerHTML = html;
            }
            contextMenu.addEventListener("input", (e) => {
                if (!currentContextMenuNode) return;
                const prop = e.target.dataset.prop;
                let value =
                    e.target.type === "number"
                        ? parseFloat(e.target.value)
                        : e.target.value;
                if (prop === "address") {
                    const oldAddress = currentContextMenuNode.attrs.address;
                    const oldValue = tagDatabase[oldAddress];
                    delete tagDatabase[oldAddress];
                    if (!(value in tagDatabase)) tagDatabase[value] = oldValue;
                }
                currentContextMenuNode.setAttr(prop, value);
                currentContextMenuNode.updateState?.();
            });
            closeContextMenuBtn.addEventListener("click", hideContextMenu);
            addComponentPanel.addEventListener("click", (e) => {
                if (e.target.matches("button[data-component]")) {
                    const type = e.target.dataset.component;
                    const component = componentFactory.create(type);
                    if (component) {
                        layer.add(component);
                        saveState();
                    }
                }
            });
            deleteBtn.addEventListener("click", () => {
                const nodesToDelete = tr.nodes();
                if (nodesToDelete.length > 0) {
                    saveState();
                    nodesToDelete.forEach((node) => {
                        delete tagDatabase[node.attrs.address];
                        node.destroy();
                    });
                }
                selectNodes([]); // Clear selection
            });
            window.addEventListener("keydown", (e) => {
                const activeEl = document.activeElement;
                if (
                    activeEl &&
                    (activeEl.tagName === "INPUT" ||
                        activeEl.tagName === "TEXTAREA")
                )
                    return;

                if ((e.ctrlKey || e.metaKey) && !isSimulationMode) {
                    if (e.key.toLowerCase() === "c") {
                        e.preventDefault();
                        handleCopy();
                    }
                    if (e.key.toLowerCase() === "v") {
                        e.preventDefault();
                        handlePaste();
                    }
                }

                if (e.key === "Escape") hideContextMenu();
                if (
                    (e.key === "Delete" || e.key === "Backspace") &&
                    tr.nodes().length > 0 &&
                    !isSimulationMode
                )
                    deleteBtn.click();
            });
            aiFab.addEventListener("click", () =>
                aiPopupChat.classList.toggle("hidden")
            );
            closeAiPopupBtn.addEventListener("click", () =>
                aiPopupChat.classList.add("hidden")
            );

            // AI Settings
            aiSettingsBtn.addEventListener("click", () => {
                aiSettingsPanel.classList.remove("hidden");
            });
            closeAiSettingsBtn.addEventListener("click", () =>
                aiSettingsPanel.classList.add("hidden")
            );

            // Menyimpan API Key
            const geminiApiKeyInput = document.getElementById("gemini-api-key");
            geminiApiKeyInput.value =
                localStorage.getItem("geminiApiKey") || ""; // Load API key
            geminiApiKeyInput.addEventListener("change", (e) =>
                localStorage.setItem("geminiApiKey", e.target.value)
            );

            function addMessageToChatLog(sender, text) {
                const messageDiv = document.createElement("div");
                messageDiv.classList.add(
                    "chat-message",
                    sender === "user" ? "user-message" : "model-message"
                );
                messageDiv.textContent = text;
                chatLog.appendChild(messageDiv);
                chatLog.scrollTop = chatLog.scrollHeight;
                chatHistory.push({ role: sender, parts: [{ text }] });
                return messageDiv;
            }
            function addThinkingDetails(planJson) {
                const details = document.createElement("details");
                details.classList.add("thinking-details");
                const summary = document.createElement("summary");
                summary.textContent = "Proses Berpikir 🧠";
                details.appendChild(summary);
                const pre = document.createElement("pre");
                pre.textContent = JSON.stringify(JSON.parse(planJson), null, 2);
                details.appendChild(pre);
                chatLog.appendChild(details);
                chatLog.scrollTop = chatLog.scrollHeight;
            }
            async function handleSendMessage() {
                const userPrompt = chatInput.value.trim();
                if (!userPrompt) return;
                addMessageToChatLog("user", userPrompt);
                chatInput.value = "";
                setLoadingState(true);
                const modelThinkingBubble = addMessageToChatLog("model", "");
                const spinner = document.createElement("div");
                spinner.className = "loader";
                modelThinkingBubble.appendChild(spinner);
                const canvasContext = getCanvasContext();
                const schema = {
                    type: "ARRAY",
                    items: {
                        type: "OBJECT",
                        properties: {
                            action: {
                                type: "STRING",
                                enum: ["add", "update", "delete", "clarify"],
                            },
                            id: { type: "STRING" },
                            componentType: {
                                type: "STRING",
                                enum: [
                                    "bit-lamp",
                                    "bit-switch",
                                    "word-lamp",
                                    "numeric-display",
                                ],
                            },
                            message: { type: "STRING" },
                            properties: {
                                type: "OBJECT",
                                properties: {
                                    x: { type: "NUMBER" },
                                    y: { type: "NUMBER" },
                                    label: { type: "STRING" },
                                    address: { type: "STRING" },
                                    shapeType: {
                                        type: "STRING",
                                        enum: ["circle", "rect"],
                                    },
                                    units: { type: "STRING" },
                                },
                            },
                        },
                        required: ["action"],
                    },
                };
                const MAX_HISTORY_TURNS = 10;
                const recentHistory = chatHistory.slice(-MAX_HISTORY_TURNS);
                const systemPrompt = `Anda adalah asisten desain HMI.
- **Aturan Utama**: Buat rencana tindakan JSON berdasarkan riwayat chat dan konteks kanvas.
- **Tindakan**: 'add', 'update', 'delete', 'clarify'.
- **Targeting**: Untuk 'update' atau 'delete', Anda **HARUS** menggunakan \`id\` unik komponen. Jangan gunakan \`address\`. \`address\` hanyalah properti yang bisa diubah.
- **Penataan Grid**: Jika pengguna meminta 'susun', 'tata', atau 'atur ulang', Anda HARUS membuat larik (array) dari beberapa tindakan \`update\` untuk **setiap** komponen yang ada, dengan mengubah properti \`x\` dan \`y\` mereka ke posisi baru yang rapi dan tidak tumpang tindih berdasarkan sistem grid (misalnya kelipatan ${
                    GRID_SIZE * 2
                } atau ${GRID_SIZE * 4}).
- **Klarifikasi**: Jika perintah tidak jelas (misalnya, menargetkan \`address\` atau \`label\` yang duplikat), **HARUS** gunakan tindakan \`clarify\` untuk bertanya kepada pengguna \`id\` mana yang mereka maksud.
- **Konteks**: Jika perintah tidak jelas TAPI ada elemen yang dipilih, terapkan perintah ke elemen yang dipilih tersebut.
- Ukuran kanvas ${stage.width()}x${stage.height()}px.`;
                const fullPayload = {
                    contents: [
                        {
                            role: "user",
                            parts: [
                                {
                                    text: `${systemPrompt}\n\nKonteks Kanvas Saat Ini:\n${canvasContext}`,
                                },
                            ],
                        },
                        {
                            role: "model",
                            parts: [{ text: "Tentu, saya siap membantu." }],
                        },
                        ...recentHistory,
                    ],
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: schema,
                    },
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${localStorage.getItem(
                    "geminiApiKey"
                )}`;
                try {
                    const response = await fetch(apiUrl, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(fullPayload),
                    });
                    if (!response.ok)
                        throw new Error(`API Error: ${response.status}`);
                    const result = await response.json();
                    spinner.remove();
                    if (result.candidates?.[0]?.content) {
                        const jsonText =
                            result.candidates[0].content.parts[0].text;
                        const actions = JSON.parse(jsonText);
                        const { actionTaken, clarificationMessage } =
                            executeAIActions(actions);
                        if (clarificationMessage) {
                            modelThinkingBubble.textContent =
                                clarificationMessage;
                            chatHistory.find(
                                (m) =>
                                    m.role === "model" && m.parts[0].text === ""
                            ).parts[0].text = clarificationMessage;
                        } else if (actionTaken) {
                            const confirmationText =
                                "Baik, sudah saya laksanakan.";
                            modelThinkingBubble.textContent = confirmationText;
                            chatHistory.find(
                                (m) =>
                                    m.role === "model" && m.parts[0].text === ""
                            ).parts[0].text = confirmationText;
                            addThinkingDetails(jsonText);
                        } else {
                            const noActionText =
                                "Sepertinya tidak ada tindakan spesifik yang bisa saya lakukan. Bisa perjelas lagi?";
                            modelThinkingBubble.textContent = noActionText;
                            chatHistory.find(
                                (m) =>
                                    m.role === "model" && m.parts[0].text === ""
                            ).parts[0].text = noActionText;
                        }
                    } else {
                        modelThinkingBubble.textContent =
                            "Saya tidak dapat memproses permintaan itu. Coba ulangi.";
                    }
                } catch (error) {
                    spinner.remove();
                    console.error("Error:", error);
                    modelThinkingBubble.textContent = `Maaf, terjadi kesalahan: ${error.message}`;
                } finally {
                    setLoadingState(false);
                }
            }
            function getCanvasContext() {
                let context = "";
                const components = layer.find(".hmi-component");
                if (components.length === 0) {
                    context += "Kanvas kosong.";
                } else {
                    context += "Komponen di kanvas:\n";
                    context += components
                        .map(
                            (n) =>
                                `- ${
                                    n.attrs.componentType
                                } (id: "${n.id()}", label: "${
                                    n.attrs.label
                                }", alamat: "${n.attrs.address}")`
                        )
                        .join("\n");
                }

                const selectedNodes = tr.nodes();
                if (selectedNodes.length > 0) {
                    context += `\n\nElemen Terpilih (${selectedNodes.length}):\n`;
                    context += selectedNodes
                        .map(
                            (n) =>
                                `- ${n.attrs.componentType} (id: "${n.id()}", alamat: "${n.attrs.address}")`
                        )
                        .join("\n");
                }
                return context;
            }
            function executeAIActions(actions) {
                if (!Array.isArray(actions))
                    return { actionTaken: false, clarificationMessage: null };
                let actionTaken = false;
                let clarificationMessage = null;
                actions.forEach((action) => {
                    const targetNode = action.id
                        ? layer.findOne("#" + action.id)
                        : null;
                    switch (action.action) {
                        case "add":
                            if (action.properties) {
                                const component = componentFactory.create(
                                    action.componentType,
                                    action.properties
                                );
                                if (component) layer.add(component);
                                actionTaken = true;
                            }
                            break;
                        case "update":
                            if (targetNode && action.properties) {
                                if (
                                    action.properties.address &&
                                    action.properties.address !==
                                        targetNode.attrs.address
                                ) {
                                    const oldAddress = targetNode.attrs.address;
                                    const newAddress =
                                        action.properties.address;
                                    tagDatabase[newAddress] =
                                        tagDatabase[oldAddress];
                                    delete tagDatabase[oldAddress];
                                }
                                targetNode.setAttrs(action.properties);
                                targetNode.updateState?.();
                                actionTaken = true;
                            }
                            break;
                        case "delete":
                            if (targetNode) {
                                delete tagDatabase[targetNode.attrs.address];
                                targetNode.destroy();
                                actionTaken = true;
                            }
                            break;
                        case "clarify":
                            if (action.message)
                                clarificationMessage = action.message;
                            break;
                    }
                });
                if (actionTaken) {
                    saveState();
                }
                return { actionTaken, clarificationMessage };
            }
            function setLoadingState(isLoading) {
                chatInput.disabled = isLoading;
                sendChatBtn.disabled = isLoading;
            }
            sendChatBtn.addEventListener("click", handleSendMessage);
            chatInput.addEventListener("keydown", (e) => {
                if (e.key === "Enter") handleSendMessage();
            });
        </script>
    </body>
</html>
